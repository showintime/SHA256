# sha256哈希散列C语言实现版本
c/c++
-----------------------------
传说中的Bitcoin就是用的SHA256的衍生版本
-----------------------------
[TOC]

拿到一些字符串后怎么实现哈希算法呢？

## 一、信息预处理

### 1、填充比特



我们填充的时候先要填充一个1，然后补0直到长度对512取模为448.
--特别说明-- 一定要进行填充，也就是说填充至少一位，最多是512.也就是说即便报文的长度对512取余为448，我们依旧需要对其填充1，然后补齐0，这样也就是为什么最多是512（1个`1`和511个`0`）.

<u>？为什么是448呢？</u> :smile:
因为512-448=64，还剩的64位来保存报文的长度，所以报文的长度是2^64次方，是一个很大很大的数！这样子整体就是512位的整数倍，方便我们以后计算~

这里假设我们的报文是字符串，也就是说按照ASCII来说是8的整数位（一个字符8位嘛~）
因为至少要填充，所以我们在报文的后边直接添加了`1000 0000`,也就是`0x80`；

### 2、附加长度
这个长度指的是报文的位数，这里的长度是不算第一步我们填充的数字的。
举个例子：
我们的报文是`0x616261`也就是'aba'，那么这里指的长度为24位（二进制的位数（bit）），一个字符8位，三个字符24位。

## 二、逻辑运算

也就是代码中的36-90行
这里大家可以看代码，我觉得必看数学公式更加直观~

## 三、计算信息摘要

### 1、分块
将填充好的消息分为512位大小的若干块，这里记作M块，也就是填充好的报文的bit是 512*M bit

然后按顺序经过操作即可！
如下图：


## 额外说明
简介其中的几个函数说明：
``` C
uint Ch(uint x, uint y, uint z)
{
	return (x&y) ^ ((~x)&z);
}
```
这个函数是实现：  

|无符号整数x,y,z|说明|
|:-:|:-:|
|x&y   |x位操作与y|
|x^y  | x异或y|
|~x  |  非x|

-----------
剩下的一些操作都是SHA256的标准，都类似于上述的函数那样，一些位运算！


``` C
uint h[8] = {
	0x6a09e667,
	0xbb67ae85,
	0x3c6ef372,
	0xa54ff53a,
	0x510e527f,
	0x9b05688c,
	0x1f83d9ab,
	0x5be0cd19
	};
```
还有`k[]`等等这些奇怪的数字，并不是我想出来的，也是约定。
